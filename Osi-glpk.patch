--- Osi-0.106.10/Osi/src/OsiGlpk/OsiGlpkSolverInterface.cpp.orig	2013-04-06 14:50:19.000000000 +0200
+++ Osi-0.106.10/Osi/src/OsiGlpk/OsiGlpkSolverInterface.cpp	2014-12-04 17:58:31.036909826 +0100
@@ -21,7 +21,7 @@
 //    In (much) earlier versions of GLPK, if an LPX_MIP problem was
 // changed back into a LPX_LP problem, then the MIP data was lost,
 // including which columns are integer.  However, LPX_MIP problems
-// still had access to LP information (like lpx_get_status).
+// still had access to LP information (like glp_get_status).
 //
 //    It appears that this behavior is no longer true in version 4.7.
 // Therefore it may be worthwhile to adjust the interface to change
@@ -166,26 +166,26 @@ void OGSI::initialSolve()
 /*
   Solve the lp.
 */
-  int err = lpx_simplex(model) ;
+  int err = glp_simplex(model, &simplexParams_) ;
 
   // for Glpk, a solve fails if the initial basis is invalid or singular
   // thus, we construct a (advanced) basis first and try again
-#ifdef LPX_E_BADB
-  if (err == LPX_E_BADB) {
-    lpx_adv_basis(model);
-    err = lpx_simplex(model) ;
+#ifdef GLP_EBADB
+  if (err == GLP_EBADB) {
+    glp_adv_basis(model, 0);
+    err = glp_simplex(model, &simplexParams_) ;
   } else
 #endif
-  if (err == LPX_E_SING || err == LPX_E_FAULT) {
-    lpx_adv_basis(model);
-    err = lpx_simplex(model) ;
+  if (err == GLP_ESING || err == GLP_EFAIL) {
+    glp_adv_basis(model, 0);
+    err = glp_simplex(model, &simplexParams_) ;
   }
 
-  iter_used_ = lpx_get_int_parm(model, LPX_K_ITCNT) ;
+  iter_used_ = glp_get_it_cnt(model) ;
 /*
   Sort out the various state indications.
 
-  When the presolver is turned on, lpx_simplex() will not be able to tell
+  When the presolver is turned on, glp_simplex() will not be able to tell
   whether the objective function has hit it's upper or lower limit, and does
   not return OBJLL or OBJUL. The code for these cases should be beefed up to
   check the objective against the limit.
@@ -204,39 +204,39 @@ void OGSI::initialSolve()
   isObjUpperLimitReached_ = false ;
 
   switch (err)
-  { case LPX_E_OK:
+  { case 0:
     { break ; }
-    case LPX_E_ITLIM:
+    case GLP_EITLIM:
     { isIterationLimitReached_ = true ;
       break ; }
-    case LPX_E_OBJLL:
+    case GLP_EOBJLL:
     { isObjLowerLimitReached_ = true ;
       break ; }
-    case LPX_E_OBJUL:
+    case GLP_EOBJUL:
     { isObjUpperLimitReached_ = true ;
       break ; }
-    case LPX_E_TMLIM:
+    case GLP_ETMLIM:
     { isTimeLimitReached_ = true ;
     } // no break here, so we still report abandoned
-    case LPX_E_FAULT:
-    case LPX_E_SING:
-#ifdef LPX_E_BADB
-    case LPX_E_BADB:
+    case GLP_EFAIL:
+    case GLP_ESING:
+#ifdef GLP_EBADB
+    case GLP_EBADB:
 #endif
     { isAbandoned_ = true ;
       break ; }
-    case LPX_E_NOPFS:
+    case GLP_ENOPFS:
     { isPrimInfeasible_ = true ;
       break ; }
-    case LPX_E_NODFS:
+    case GLP_ENODFS:
     { isDualInfeasible_ = true ;
       break ; }
     default:
     { assert(false) ; } }
     
-  switch (lpx_get_status(model))
-  { case LPX_OPT:
-  	case LPX_FEAS:
+  switch (glp_get_status(model))
+  { case GLP_OPT:
+  	case GLP_FEAS:
   	{ isFeasible_ = true ;
   		break ; }
   	default:
@@ -261,23 +261,23 @@ void OGSI::resolve()
   LPX *model = getMutableModelPtr() ;
   freeCachedData(OGSI::FREECACHED_RESULTS) ;
 
-  // lpx_simplex will use the current basis if possible
-  int err = lpx_simplex(model) ;
+  // glp_simplex will use the current basis if possible
+  int err = glp_simplex(model, &simplexParams_) ;
 
   // for Glpk, a solve fails if the initial basis is invalid or singular
   // thus, we construct a (advanced) basis first and try again
-#ifdef LPX_E_BADB
-  if (err == LPX_E_BADB) {
-    lpx_adv_basis(model);
-    err = lpx_simplex(model) ;
+#ifdef GLP_EBADB
+  if (err == GLP_EBADB) {
+    glp_adv_basis(model, 0);
+    err = glp_simplex(model, &simplexParams_) ;
   } else
 #endif
-  if (err == LPX_E_SING || err == LPX_E_FAULT) {
-    lpx_adv_basis(model);
-    err = lpx_simplex(model) ;
+  if (err == GLP_ESING || err == GLP_EFAIL) {
+    glp_adv_basis(model, 0);
+    err = glp_simplex(model, &simplexParams_) ;
   }
   
-  iter_used_ = lpx_get_int_parm(model,LPX_K_ITCNT) ;
+  iter_used_ = glp_get_it_cnt(model) ;
 
   isIterationLimitReached_ = false ;
   isTimeLimitReached_ = false ;
@@ -289,39 +289,39 @@ void OGSI::resolve()
   isFeasible_ = false ;
 
   switch (err)
-  { case LPX_E_OK:
+  { case 0:
     { break ; }
-    case LPX_E_ITLIM:
+    case GLP_EITLIM:
     { isIterationLimitReached_ = true ;
       break ; }
-    case LPX_E_OBJLL:
+    case GLP_EOBJLL:
     { isObjLowerLimitReached_ = true ;
       break ; }
-    case LPX_E_OBJUL:
+    case GLP_EOBJUL:
     { isObjUpperLimitReached_ = true ;
       break ; }
-    case LPX_E_TMLIM:
+    case GLP_ETMLIM:
     { isTimeLimitReached_ = true ;
     } // no break here, so we still report abandoned
-    case LPX_E_FAULT:
-    case LPX_E_SING:
-#ifdef LPX_E_BADB
-    case LPX_E_BADB:
+    case GLP_EFAIL:
+    case GLP_ESING:
+#ifdef GLP_EBADB
+    case GLP_EBADB:
 #endif
     { isAbandoned_ = true ;
       break ; }
-    case LPX_E_NOPFS:
+    case GLP_ENOPFS:
     { isPrimInfeasible_ = true ;
       break ; }
-    case LPX_E_NODFS:
+    case GLP_ENODFS:
     { isDualInfeasible_ = true ;
       break ; }
     default:
     { assert(false) ; } }
 
-  switch (lpx_get_status(model))
-  { case LPX_OPT:
-  	case LPX_FEAS:
+  switch (glp_get_status(model))
+  { case GLP_OPT:
+  	case GLP_FEAS:
   	{ isFeasible_ = true ;
   		break ; }
   	default:
@@ -337,7 +337,7 @@ void OGSI::resolve()
 
 /*
   Call glpk's built-in MIP solver. Any halfway recent version (from glpk 4.4,
-  at least) will have lpx_intopt, a branch-and-cut solver. The presence of cut
+  at least) will have glp_intopt, a branch-and-cut solver. The presence of cut
   generators is more recent.
 */
 void OGSI::branchAndBound ()
@@ -351,52 +351,46 @@ void OGSI::branchAndBound ()
   Assuming we have integer variables in the model, call the best MIP solver
   we can manage.
 
-  lpx_intopt does not require an optimal LP solution as a starting point, so
+  glp_intopt does not require an optimal LP solution as a starting point, so
   we can call it directly.
 
   lpx_integer needs an initial optimal solution to the relaxation.
 */
-  if (lpx_get_num_int(model))
-  { int err = LPX_E_FAULT ;
+  if (glp_get_num_int(model))
+  { int err = GLP_EFAIL ;
 
-#   ifdef GLPK_HAS_INTOPT
-    err = lpx_intopt(model) ;
-#   else
-    if (lpx_get_status(model) != LPX_OPT)
-    { initialSolve() ; }
-    err = lpx_integer(model) ;
-#   endif
+    err = glp_intopt(model, &intoptParams_) ;
 /*
   We have a result. What is it? Start with a positive attitude and revise as
-  needed. The various LPX_E_* and LPX_I_* defines are stable back as far as
-  glpk-4.4.
+  needed. The various GLP_E* and GLP_* defines are stable back as far as
+  glpk-4.5x.
 
-  When we get LPX_E_OK (MIP terminated normally), we need to look more
-  closely.  LPX_I_OPT indicates a proven optimal integer solution.
-  LPX_I_NOFEAS indicates that there is no integer feasible solution.
-  LPX_I_UNDEF says the MIP solution is undefined. LPX_I_FEAS says that in
+  When we get 0 (MIP terminated normally), we need to look more
+  closely.  GLP_OPT indicates a proven optimal integer solution.
+  GLP_NOFEAS indicates that there is no integer feasible solution.
+  GLP_UNDEF says the MIP solution is undefined. GLP_FEAS says that in
   integer feasible solution was found but not proven optimal (termination of
   search due to some limit is the common cause). It's not clear what to do
-  with LPX_I_UNDEF; currently, it is not really reflected in
-  termination status. LPX_I_FEAS is reflected by the OsiGlpk specific method
+  with GLP_UNDEF; currently, it is not really reflected in
+  termination status. GLP_FEAS is reflected by the OsiGlpk specific method
   isFeasible().
 
-  Various other codes are returned by lpx_intopt (lpx_integer returns a
-  subset of these).  LPX_E_NOPFS (LPX_E_NODFS) indicate no primal (dual)
+  Various other codes are returned by glp_intopt (lpx_integer returns a
+  subset of these).  GLP_ENOPFS (GLP_ENODFS) indicate no primal (dual)
   feasible solution; detected at the root, either by presolve or when
-  attempting the root relaxation. LPX_E_ITLIM (LPX_E_TMLIM) indicate
+  attempting the root relaxation. GLP_EITLIM (GLP_ETMLIM) indicate
   iteration (time) limit reached. Osi doesn't provide for time limit, so lump
   it in with iteration limit (an arguable choice, but seems better than the
   alternatives) and have extra method isTimeLimitReached().
-  LPX_E_SING (lp solver failed due to singular basis) is
-  legimately characterised as abandoned.  LPX_E_FAULT indicates a structural
+  GLP_ESING (lp solver failed due to singular basis) is
+  legimately characterised as abandoned.  GLP_EFAIL indicates a structural
   problem (problem not of class MIP, or an integer variable has a non-integer
   bound), which really translates into internal confusion in OsiGlpk.
 
   Previous comments expressed uncertainty about the iteration count. This
   should be checked at some point. -- lh, 070709 --
 */
-    iter_used_ = lpx_get_int_parm(model,LPX_K_ITCNT) ;
+    iter_used_ = glp_get_it_cnt(model) ;
     isIterationLimitReached_ = false ;
 		isTimeLimitReached_ = false ;
     isAbandoned_ = false ;
@@ -407,45 +401,45 @@ void OGSI::branchAndBound ()
     isObjUpperLimitReached_ = false ;
 
     switch (err)
-    { case LPX_E_OK:
-#ifdef LPX_E_MIPGAP
-    case LPX_E_MIPGAP:
+    { case 0:
+#ifdef GLP_EMIPGAP
+    case GLP_EMIPGAP:
 #endif
       { 
 	break ; }
-      case LPX_E_NOPFS:
+      case GLP_ENOPFS:
       { isPrimInfeasible_ = true ;
 	break ; }
-      case LPX_E_NODFS:
+      case GLP_ENODFS:
       { isDualInfeasible_ = true ;
 	break ; }
-      case LPX_E_TMLIM:
+      case GLP_ETMLIM:
       { isTimeLimitReached_ = true ; } // no break
-      case LPX_E_ITLIM:
+      case GLP_EITLIM:
       { isIterationLimitReached_ = true ;
 	break ; }
-      case LPX_E_SING:
+      case GLP_ESING:
       { isAbandoned_ = true ;
 	break ; }
-      case LPX_E_FAULT:
+      case GLP_EFAIL:
       { assert(false) ;
 	break ; }
       default:
       { assert(false) ;
 	break ; } }
 	
-	//check this also if err!=LPX_E_OPT, so we know about feasibility in case time/resource limit is reached  
-	int mip_status = lpx_mip_status(model) ;
+	//check this also if err!=GLP_OPT, so we know about feasibility in case time/resource limit is reached  
+	int mip_status = glp_mip_status(model) ;
 	switch (mip_status)
-	{ case LPX_I_OPT:
+	{ case GLP_OPT:
 	  { isFeasible_ = true ;
 	  	break ; }
-	  case LPX_I_NOFEAS:
+	  case GLP_NOFEAS:
 	  { isPrimInfeasible_ = true ;
 	    break ; }
-	  case LPX_I_UNDEF:
+	  case GLP_UNDEF:
 	  { break ; }
-	  case LPX_I_FEAS:
+	  case GLP_FEAS:
 	  { isFeasible_ = true ;
 	  	break ; }
 	  default:
@@ -458,7 +452,7 @@ void OGSI::branchAndBound ()
 /*
   Not a MIP (no integer variables). Call the LP solver. Since we can call
   branchAndBound with no initial LP solution, initialSolve is appropriate here.
-  (But for glpk, it actually makes no difference --- lpx_simplex makes the
+  (But for glpk, it actually makes no difference --- glp_simplex makes the
   decision on how to proceed.)
 */
   else
@@ -490,7 +484,7 @@ bool OGSI::setIntParam (OsiIntParam key,
   { case OsiMaxNumIteration:
     { if (value >= 0)
       { maxIteration_ = value ;
-	lpx_set_int_parm(lp_,LPX_K_ITLIM,value) ;
+	simplexParams_.it_lim = value ;
 	retval = true ; }
       else
       { retval = false ; }
@@ -531,24 +525,24 @@ bool OGSI::setDblParam (OsiDblParam key,
     // as of 4.7, GLPK only uses this if it does dual simplex
     { dualObjectiveLimit_ = value ;
       if (getObjSense() == 1)				// minimization
-      { lpx_set_real_parm(lp_,LPX_K_OBJUL,value) ; }
+      { simplexParams_.obj_ul = value ; }
       else              				// maximization
-      { lpx_set_real_parm(lp_,LPX_K_OBJLL,value) ; }
+      { simplexParams_.obj_ll = value ; }
       retval = true ; 
       break ; }
     case OsiPrimalObjectiveLimit:
     // as of 4.7, GLPK only uses this if it does dual simplex
     { primalObjectiveLimit_ = value ;
       if (getObjSense() == 1)
-      { lpx_set_real_parm(lp_,LPX_K_OBJLL,value) ; }
+      { simplexParams_.obj_ll = value ; }
       else
-      { lpx_set_real_parm(lp_,LPX_K_OBJUL,value) ; }
+      { simplexParams_.obj_ul = value ; }
       retval = true ; 
       break ; }
     case OsiDualTolerance:
     { if (value >= 0 && value <= .001)
       { dualTolerance_ = value;
-	lpx_set_real_parm(lp_,LPX_K_TOLDJ,value) ;
+	simplexParams_.tol_dj = value ;
 	retval = true ; }
       else
       { retval = false ; }
@@ -556,14 +550,14 @@ bool OGSI::setDblParam (OsiDblParam key,
     case OsiPrimalTolerance:
     { if (value >= 0 && value <= .001)
       { primalTolerance_ = value ;
-	lpx_set_real_parm(lp_,LPX_K_TOLBND,value) ;
+	simplexParams_.tol_bnd = value ;
 	retval = true ; }
       else
       { retval = false ; }
       break ; }
     case OsiObjOffset:
     { objOffset_ = value ;
-      lpx_set_obj_coef(lp_,0,value) ;
+      glp_set_obj_coef(lp_,0,value) ;
       retval = true ;
       break ; }
     case OsiLastDblParam:
@@ -583,7 +577,7 @@ bool OGSI::setStrParam (OsiStrParam key,
     { probName_ = value ;
       if (probName_.length() == 0)
         probName_ = "Pb";
-      lpx_set_prob_name(lp_,const_cast<char *>(value.c_str())) ;
+      glp_set_prob_name(lp_,const_cast<char *>(value.c_str())) ;
       retval = true ;
       break ; }
     case OsiSolverName:
@@ -665,18 +659,18 @@ bool OGSI::setHintParam (OsiHintParam ke
     case OsiDoPresolveInInitial:
     case OsiDoPresolveInResolve:
     { if (sense == false)
-      { if (strength >= OsiHintTry) lpx_set_int_parm(lp_,LPX_K_PRESOL,0) ; }
+      { if (strength >= OsiHintTry) simplexParams_.presolve = intoptParams_.presolve = 0 ; }
       else
-      { lpx_set_int_parm(lp_,LPX_K_PRESOL,1) ; }
+      { simplexParams_.presolve = intoptParams_.presolve = 1 ; }
       retval = true ;
       break ; }
     case OsiDoDualInInitial:
     case OsiDoDualInResolve:
     { unimp_hint(msgHdl,false,sense,strength,"exclusive use of dual simplex") ;
       if (sense == false)
-      { if (strength >= OsiHintDo) lpx_set_int_parm(lp_,LPX_K_DUAL,0) ; }
+      { if (strength >= OsiHintDo) simplexParams_.meth = GLP_PRIMAL ; }
       else
-      { lpx_set_int_parm(lp_,LPX_K_DUAL,1) ; }
+      { simplexParams_.meth = GLP_DUALP ; }
       retval = true ;
       break ; }
     case OsiDoCrash:
@@ -692,9 +686,10 @@ bool OGSI::setHintParam (OsiHintParam ke
 */
     case OsiDoScale:
     { if (sense == false)
-      { if (strength >= OsiHintTry) lpx_set_int_parm(lp_,LPX_K_SCALE,0) ; }
+      { if (strength >= OsiHintTry) scaleFlags_ = 0 ; }
       else
-      { lpx_set_int_parm(lp_,LPX_K_SCALE,3) ; }
+      { scaleFlags_ = GLP_SF_GM | GLP_SF_EQ ; }
+      glp_scale_prob(lp_, scaleFlags_);
       retval = true ;
       break ; }
 /*
@@ -704,15 +699,15 @@ bool OGSI::setHintParam (OsiHintParam ke
     case OsiDoReducePrint:
     { if (sense == true)
       { if (strength <= OsiHintTry)
-	{ lpx_set_int_parm(lp_,LPX_K_MSGLEV,1) ; }
+	{ simplexParams_.msg_lev = intoptParams_.msg_lev = GLP_MSG_ERR ; }
 	else
-	{ lpx_set_int_parm(lp_,LPX_K_MSGLEV,0) ; } }
+	{ simplexParams_.msg_lev = intoptParams_.msg_lev = GLP_MSG_OFF ; } }
       else
       { if (strength <= OsiHintTry)
-	{ lpx_set_int_parm(lp_,LPX_K_MSGLEV,2) ; }
+	{ simplexParams_.msg_lev = intoptParams_.msg_lev = GLP_MSG_ON ; }
 	else
-	{ lpx_set_int_parm(lp_,LPX_K_MSGLEV,3) ; } }
-      int logLevel = lpx_get_int_parm(lp_,LPX_K_MSGLEV) ;
+	{ simplexParams_.msg_lev = intoptParams_.msg_lev = GLP_MSG_ALL ; } }
+      int logLevel = simplexParams_.msg_lev ;
       messageHandler()->setLogLevel(logLevel) ;
       retval = true ;
       break ; }
@@ -787,7 +782,7 @@ OGSI::getDblParam( OsiDblParam key, doub
 		break;
 
     case OsiObjOffset:
-                value = lpx_get_obj_coef(getMutableModelPtr(),0);
+                value = glp_get_obj_coef(getMutableModelPtr(),0);
 		retval = true;
 		break;
 
@@ -805,7 +800,7 @@ OGSI::getStrParam(OsiStrParam key, std::
   //	bool retval = false;
   switch (key) {
   case OsiProbName:
-    value = lpx_get_prob_name( getMutableModelPtr() );
+    value = glp_get_prob_name( getMutableModelPtr() );
     break;
   case OsiSolverName:
     value = "glpk";
@@ -830,13 +825,13 @@ bool OGSI::isProvenOptimal() const
 
 	if( bbWasLast_ == 0 )
 	  {
-	    int stat = lpx_get_status( model );
-	    return stat == LPX_OPT;
+	    int stat = glp_get_status( model );
+	    return stat == GLP_OPT;
 	  }
 	else
 	  {
-	    int stat = lpx_mip_status( model );
-	    return stat == LPX_I_OPT;
+	    int stat = glp_mip_status( model );
+	    return stat == GLP_OPT;
 	  }
 }
 
@@ -848,9 +843,9 @@ bool OGSI::isProvenPrimalInfeasible() co
 		return true;
 
 	if( bbWasLast_ == 0 )
-		return lpx_get_prim_stat( model ) == LPX_P_NOFEAS;
+		return glp_get_prim_stat( model ) == GLP_NOFEAS;
 	else
-		return lpx_mip_status( model ) == LPX_I_NOFEAS;
+		return glp_mip_status( model ) == GLP_NOFEAS;
 }
 
 bool OGSI::isProvenDualInfeasible() const
@@ -861,7 +856,7 @@ bool OGSI::isProvenDualInfeasible() cons
 		return true;
 
 	if( bbWasLast_ == 0 )
-		return lpx_get_dual_stat( model ) == LPX_D_NOFEAS;
+		return glp_get_dual_stat( model ) == GLP_NOFEAS;
 	else
 	  // Not sure what to do for MIPs;  does it just mean unbounded?
 	  // ??? for now, return false
@@ -933,7 +928,7 @@ bool OGSI::isFeasible() const
 /*
   Return a warm start object matching the current state of the solver.
 
-  Nonbasic fixed variables (LPX_NS) are translated to CWSB::atLowerBound.
+  Nonbasic fixed variables (GLP_NS) are translated to CWSB::atLowerBound.
 */
 CoinWarmStart *OGSI::getWarmStart() const
 
@@ -953,19 +948,19 @@ CoinWarmStart *OGSI::getWarmStart() cons
    and  Glpk's at-upper-bound will be mapped to Osi's at-lower-bound. 
 */
   for (int i = 0 ; i < numrows ; i++)
-  { int stati = lpx_get_row_stat(lp_,i+1) ;
+  { int stati = glp_get_row_stat(lp_,i+1) ;
     switch (stati)
-    { case LPX_BS:
+    { case GLP_BS:
       { ws->setArtifStatus(i,CoinWarmStartBasis::basic) ;
 	break ; }
-      case LPX_NS:
-      case LPX_NL:
+      case GLP_NS:
+      case GLP_NL:
       { ws->setArtifStatus(i,CoinWarmStartBasis::atUpperBound) ;
 	break ; }
-      case LPX_NU:
+      case GLP_NU:
       { ws->setArtifStatus(i,CoinWarmStartBasis::atLowerBound) ;
 	break ; }
-      case LPX_NF:
+      case GLP_NF:
       { ws->setArtifStatus(i,CoinWarmStartBasis::isFree) ;
 	break ; }
       default:
@@ -975,19 +970,19 @@ CoinWarmStart *OGSI::getWarmStart() cons
   And repeat for the columns.
 */
   for (int j = 0 ; j < numcols ; j++)
-  { int statj = lpx_get_col_stat(lp_,j+1) ;
+  { int statj = glp_get_col_stat(lp_,j+1) ;
     switch (statj)
-    { case LPX_BS:
+    { case GLP_BS:
       { ws->setStructStatus(j,CoinWarmStartBasis::basic) ;
 	break ; }
-      case LPX_NS:
-      case LPX_NL:
+      case GLP_NS:
+      case GLP_NL:
       { ws->setStructStatus(j,CoinWarmStartBasis::atLowerBound) ;
 	break ; }
-      case LPX_NU:
+      case GLP_NU:
       { ws->setStructStatus(j,CoinWarmStartBasis::atUpperBound) ;
 	break ; }
-      case LPX_NF:
+      case GLP_NF:
       { ws->setStructStatus(j,CoinWarmStartBasis::isFree) ;
 	break ; }
       default:
@@ -1040,44 +1035,44 @@ bool OGSI::setWarmStart (const CoinWarmS
 
     switch (ws->getArtifStatus(i))
     { case CoinWarmStartBasis::basic:
-      { stati = LPX_BS ;
+      { stati = GLP_BS ;
 	break ; }
       case CoinWarmStartBasis::atLowerBound:
-      { stati = LPX_NU ;
+      { stati = GLP_NU ;
 	break ; }
       case CoinWarmStartBasis::atUpperBound:
-      { stati = LPX_NL ;
+      { stati = GLP_NL ;
 	break ; }
       case CoinWarmStartBasis::isFree:
-      { stati = LPX_NF ;
+      { stati = GLP_NF ;
 	break ; }
       default:
       { assert(false) ;
 	return (false) ; } }		
 
-    lpx_set_row_stat(lp_,i+1,stati) ; }
+    glp_set_row_stat(lp_,i+1,stati) ; }
   
   for (int j = 0 ; j < numcols ; j++)
   { int statj ;
 
     switch (ws->getStructStatus(j))
     { case CoinWarmStartBasis::basic:
-      { statj = LPX_BS ;
+      { statj = GLP_BS ;
 	break ; }
       case CoinWarmStartBasis::atLowerBound:
-      { statj = LPX_NL ;
+      { statj = GLP_NL ;
 	break ; }
       case CoinWarmStartBasis::atUpperBound:
-      { statj = LPX_NU ;
+      { statj = GLP_NU ;
 	break ; }
       case CoinWarmStartBasis::isFree:
-      { statj = LPX_NF ;
+      { statj = GLP_NF ;
 	break ; }
       default:
       { assert(false) ;
 	return (false) ; } }
 
-    lpx_set_col_stat(lp_,j+1,statj) ; }
+    glp_set_col_stat(lp_,j+1,statj) ; }
 
   return (true) ; }
 
@@ -1108,9 +1103,9 @@ void OGSI::markHotStart()
 		int stat;
 		double val;
 		double dualVal;
-		stat=lpx_get_col_stat(model,j);
-		val=lpx_get_col_prim(model,j);
-		dualVal=lpx_get_col_dual(model,j);
+		stat=glp_get_col_stat(model,j);
+		val=glp_get_col_prim(model,j);
+		dualVal=glp_get_col_dual(model,j);
 		hotStartCStat_[j] = stat;
 		hotStartCVal_[j] = val;
 		hotStartCDualVal_[j] = dualVal;
@@ -1131,9 +1126,9 @@ void OGSI::markHotStart()
 		int stat;
 		double val;
 		double dualVal;
-		stat=lpx_get_row_stat(model,i+1);
-		val=lpx_get_row_prim(model,i+1);
-		dualVal=lpx_get_row_dual(model,i+1);
+		stat=glp_get_row_stat(model,i+1);
+		val=glp_get_row_prim(model,i+1);
+		dualVal=glp_get_row_dual(model,i+1);
 		hotStartRStat_[i] = stat;
 		hotStartRVal_[i] = val;
 		hotStartRDualVal_[i] = dualVal;
@@ -1160,11 +1155,11 @@ void OGSI::solveFromHotStart()
 
 	int j;
 	for( j = 0; j < numcols; j++ ) {
-	  lpx_set_col_stat( model, j+1, hotStartCStat_[j]);
+	  glp_set_col_stat( model, j+1, hotStartCStat_[j]);
 	}
 	int i;
 	for( i = 0; i < numrows; i++ ) {
-	  lpx_set_row_stat( model, i+1, hotStartRStat_[i]);
+	  glp_set_row_stat( model, i+1, hotStartRStat_[i]);
 	}
 
 	freeCachedData( OGSI::FREECACHED_RESULTS );
@@ -1191,17 +1186,17 @@ void OGSI::unmarkHotStart()
 //-----------------------------------------------------------------------------
 int OGSI::getNumCols() const
 {
-	return lpx_get_num_cols( getMutableModelPtr() );
+	return glp_get_num_cols( getMutableModelPtr() );
 }
 
 int OGSI::getNumRows() const
 {
-	return lpx_get_num_rows( getMutableModelPtr() );
+	return glp_get_num_rows( getMutableModelPtr() );
 }
 
 int OGSI::getNumElements() const
 {
-	return lpx_get_num_nz( getMutableModelPtr() );
+	return glp_get_num_nz( getMutableModelPtr() );
 }
 
 //-----------------------------------------------------------------------------
@@ -1230,26 +1225,26 @@ const double * OGSI::getColLower() const
 			int type;
 			double lb;
 			double ub;
-			type=lpx_get_col_type(model,i+1);
-			lb=lpx_get_col_lb(model,i+1);
-			ub=lpx_get_col_ub(model,i+1);
+			type=glp_get_col_type(model,i+1);
+			lb=glp_get_col_lb(model,i+1);
+			ub=glp_get_col_ub(model,i+1);
 			switch ( type )
 			{
-			case LPX_FR:
+			case GLP_FR:
 				lb = -inf;
 				ub = inf;
 				break;
 
-			case LPX_LO:
+			case GLP_LO:
 				ub = inf;
 				break;
 
-			case LPX_UP:
+			case GLP_UP:
 				lb = -inf;
 				break;
 
-			case LPX_FX:
-			case LPX_DB:
+			case GLP_FX:
+			case GLP_DB:
 				break;
 
 			default:
@@ -1355,26 +1350,26 @@ const double * OGSI::getRowLower() const
 			int type;
 			double lb;
 			double ub;
-			type=lpx_get_row_type(model,i+1);
-			lb=lpx_get_row_lb(model,i+1);
-			ub=lpx_get_row_ub(model,i+1);
+			type=glp_get_row_type(model,i+1);
+			lb=glp_get_row_lb(model,i+1);
+			ub=glp_get_row_ub(model,i+1);
 			switch( type )
 			{
-			case LPX_FR:
+			case GLP_FR:
 				lb = -inf;
 				ub = inf;
 				break;
 
-			case LPX_LO:
+			case GLP_LO:
 				ub = inf;
 				break;
 
-			case LPX_UP:
+			case GLP_UP:
 				lb = -inf;
 				break;
 
-			case LPX_DB:
-			case LPX_FX:
+			case GLP_DB:
+			case GLP_FX:
 				break;
 
 			default:
@@ -1416,7 +1411,7 @@ const double * OGSI::getObjCoefficients(
 		int i;
 		for( i = 0; i < numcols; i++ )
 		{
-			obj_[i] = lpx_get_obj_coef( model, i + 1);
+			obj_[i] = glp_get_obj_coef( model, i + 1);
 		}
 	}
 	return obj_;
@@ -1426,10 +1421,10 @@ const double * OGSI::getObjCoefficients(
 
 double OGSI::getObjSense() const
 
-{ if (lpx_get_obj_dir(lp_) == LPX_MIN)
+{ if (glp_get_obj_dir(lp_) == GLP_MIN)
   { return (+1.0) ; }
   else
-  if (lpx_get_obj_dir(lp_) == LPX_MAX)
+  if (glp_get_obj_dir(lp_) == GLP_MAX)
   { return (-1.0) ; }
   else	// internal confusion
   { assert(false) ;
@@ -1441,7 +1436,7 @@ double OGSI::getObjSense() const
 
 bool OGSI::isContinuous( int colNumber ) const
 {
-  return lpx_get_col_kind( getMutableModelPtr(), colNumber+1 ) == LPX_CV;
+  return glp_get_col_kind( getMutableModelPtr(), colNumber+1 ) == GLP_CV;
 }
 
 //-----------------------------------------------------------------------------
@@ -1464,14 +1459,14 @@ const CoinPackedMatrix * OGSI::getMatrix
 		int i;
 		for( i = 0; i < getNumRows(); i++ )
 		{
-			int colsize = lpx_get_mat_row( model, i+1, colind, colelem);
+			int colsize = glp_get_mat_row( model, i+1, colind, colelem);
 			int j;
 			for( j = 1; j <= colsize; j++ )
 			{
 				--colind[j];
 			}
 
-			// Note:  lpx_get_mat_row apparently may return the
+			// Note:  glp_get_mat_row apparently may return the
 			// elements in decreasing order.  This differs from
 			// people's standard expectations but is not an error.
 
@@ -1502,7 +1497,7 @@ const CoinPackedMatrix * OGSI::getMatrix
 		int j;
 		for( j = 0; j < getNumCols(); j++ )
 		{
-			int rowsize = lpx_get_mat_col( model, j+1, rowind, rowelem);
+			int rowsize = glp_get_mat_col( model, j+1, rowind, rowelem);
 			int i;
 			for( i = 1; i <= rowsize; i++ )
 			{
@@ -1563,9 +1558,9 @@ const double *OGSI::getColSolution() con
 */
   int probStatus ;
   if (bbWasLast_)
-  { probStatus = lpx_mip_status(lp_) ; }
+  { probStatus = glp_mip_status(lp_) ; }
   else
-  { probStatus = lpx_get_status(lp_) ; }
+  { probStatus = glp_get_status(lp_) ; }
 /*
   If the problem hasn't been solved, glpk returns zeros, but OSI requires that
   the solution be within bound. getColLower() will ensure both upper and lower
@@ -1573,7 +1568,7 @@ const double *OGSI::getColSolution() con
   collower[j] < colupper[j]). Solution values will be 0.0 unless that's outside
   the bounds.
 */
-  if (probStatus == LPX_UNDEF || probStatus == LPX_I_UNDEF)
+  if (probStatus == GLP_UNDEF)
   { getColLower() ;
     int j ;
     for (j = 0 ; j < numcols ; j++)
@@ -1591,10 +1586,10 @@ const double *OGSI::getColSolution() con
   if (bbWasLast_ == 0)
   { int j ;
     for (j = 0 ; j < numcols ; j++)
-    { colsol_[j] = lpx_get_col_prim(lp_,j+1) ;
+    { colsol_[j] = glp_get_col_prim(lp_,j+1) ;
       if (fabs(colsol_[j]) < GlpkZeroTol)
       { colsol_[j] = 0.0 ; }
-      redcost_[j] = lpx_get_col_dual(lp_,j+1) ;
+      redcost_[j] = glp_get_col_dual(lp_,j+1) ;
       if (fabs(redcost_[j]) < GlpkZeroTol)
       { redcost_[j] = 0.0 ; } } }
 /*
@@ -1604,7 +1599,7 @@ const double *OGSI::getColSolution() con
   else
   { int j ;
     for (j = 0 ; j < numcols ; j++)
-    { colsol_[j] = lpx_mip_col_val(lp_,j+1) ;
+    { colsol_[j] = glp_mip_col_val(lp_,j+1) ;
       if (fabs(colsol_[j]) < GlpkZeroTol)
       { colsol_[j] = 0.0 ; }
       redcost_[j] = 0.0 ; } }
@@ -1641,7 +1636,7 @@ const double *OGSI::getRowPrice() const
   if (bbWasLast_ == 0)
   { int i ;
     for (i = 0 ; i < numrows; i++)
-    { rowsol_[i] = lpx_get_row_dual(lp_,i+1) ;
+    { rowsol_[i] = glp_get_row_dual(lp_,i+1) ;
       if (fabs(rowsol_[i]) < GlpkZeroTol)
       { rowsol_[i] = 0.0 ; } } }
   else
@@ -1658,7 +1653,7 @@ const double *OGSI::getRowPrice() const
   setRowPrice(), and it'd be nice to return reduced costs that agree with the
   duals.
 
-  To use glpk's routine (lpx_get_col_dual), the interface needs to track the
+  To use glpk's routine (glp_get_col_dual), the interface needs to track the
   origin of the dual (row price) values.
 */
 const double * OGSI::getReducedCost() const
@@ -1813,7 +1808,7 @@ void OGSI::setObjCoeff (int j, double cj
 /*
   Push the changed objective down to glpk.
 */
-  lpx_set_obj_coef(lp_,j+1,cj) ;
+  glp_set_obj_coef(lp_,j+1,cj) ;
 
   if (obj_)
   { obj_[j] = cj ; }
@@ -1830,15 +1825,15 @@ void OGSI::setColLower (int j, double lb
   infinite bound, so we need to check the status and possibly correct.
 */
   double inf = getInfinity() ;
-  int type = lpx_get_col_type(lp_,j+1) ;
-  double ubj = lpx_get_col_ub(lp_,j+1) ;
+  int type = glp_get_col_type(lp_,j+1) ;
+  double ubj = glp_get_col_ub(lp_,j+1) ;
   switch (type)
-  { case LPX_UP:
-    case LPX_DB:
-    case LPX_FX:
+  { case GLP_UP:
+    case GLP_DB:
+    case GLP_FX:
     { break ; }
-    case LPX_FR:
-    case LPX_LO:
+    case GLP_FR:
+    case GLP_LO:
     { ubj = inf ;
       break ; }
     default:
@@ -1875,15 +1870,15 @@ void OGSI::setColUpper (int j, double ub
   infinite bound, so we need to check the status and possibly correct.
 */
   double inf = getInfinity() ;
-  int type = lpx_get_col_type(lp_,j+1) ;
-  double lbj = lpx_get_col_lb(lp_,j+1) ;
+  int type = glp_get_col_type(lp_,j+1) ;
+  double lbj = glp_get_col_lb(lp_,j+1) ;
   switch (type)
-  { case LPX_LO:
-    case LPX_DB:
-    case LPX_FX:
+  { case GLP_LO:
+    case GLP_DB:
+    case GLP_FX:
     { break ; }
-    case LPX_FR:
-    case LPX_UP:
+    case GLP_FR:
+    case GLP_UP:
     { lbj = inf ;
       break ; }
     default:
@@ -1932,25 +1927,25 @@ void OGSI::setColBounds (int j, double l
   int type ;
 
   if (lower == upper)
-  { type = LPX_FX ; }
+  { type = GLP_FX ; }
   else
   if (lower > -inf && upper < inf)
-  { type = LPX_DB ; }
+  { type = GLP_DB ; }
   else
   if (lower > -inf)
-  { type = LPX_LO ; }
+  { type = GLP_LO ; }
   else
   if (upper < inf)
-  { type = LPX_UP ; }
+  { type = GLP_UP ; }
   else
-  { type = LPX_FR ; }
+  { type = GLP_FR ; }
 /*
   Push the bound change down into the solver. 1-based addressing.
 */
-  int statj = lpx_get_col_stat(lp_,j+1) ;
-  lpx_set_col_bnds(lp_,j+1,type,lower,upper) ;
-  lpx_set_col_stat(lp_,j+1,statj) ;
-  statj = lpx_get_col_stat(lp_,j+1) ;
+  int statj = glp_get_col_stat(lp_,j+1) ;
+  glp_set_col_bnds(lp_,j+1,type,lower,upper) ;
+  glp_set_col_stat(lp_,j+1,statj) ;
+  statj = glp_get_col_stat(lp_,j+1) ;
 /*
   Correct the cached upper and lower bound vectors, if present.
 */
@@ -1982,18 +1977,18 @@ OGSI::setRowLower( int elementIndex, dou
 	double lb;
 	double ub;
 
-	type=lpx_get_row_type(getMutableModelPtr(),elementIndex+1);
-	ub=lpx_get_row_ub(getMutableModelPtr(),elementIndex+1);
+	type=glp_get_row_type(getMutableModelPtr(),elementIndex+1);
+	ub=glp_get_row_ub(getMutableModelPtr(),elementIndex+1);
 	lb = elementValue;
 	switch( type )
 	{
-	case LPX_UP:
-	case LPX_DB:
-	case LPX_FX:
+	case GLP_UP:
+	case GLP_DB:
+	case GLP_FX:
 		break;
 
-	case LPX_FR:
-	case LPX_LO:
+	case GLP_FR:
+	case GLP_LO:
 		ub = inf;
 		break;
 
@@ -2014,18 +2009,18 @@ OGSI::setRowUpper( int elementIndex, dou
 	double lb;
 	double ub;
 
-	type=lpx_get_row_type(getMutableModelPtr(),elementIndex+1);
-	lb=lpx_get_row_lb(getMutableModelPtr(),elementIndex+1);
+	type=glp_get_row_type(getMutableModelPtr(),elementIndex+1);
+	lb=glp_get_row_lb(getMutableModelPtr(),elementIndex+1);
 	ub = elementValue;
 	switch( type )
 	{
-	case LPX_LO:
-	case LPX_DB:
-	case LPX_FX:
+	case GLP_LO:
+	case GLP_DB:
+	case GLP_FX:
 		break;
 
-	case LPX_FR:
-	case LPX_UP:
+	case GLP_FR:
+	case GLP_UP:
 		lb = -inf;
 		break;
 
@@ -2056,20 +2051,20 @@ void OGSI::setRowBounds (int i, double l
   int type ;
 
   if( lower == upper)
-  { type = LPX_FX ; }
+  { type = GLP_FX ; }
   else
   if (lower > -inf && upper < inf)
-  { type = LPX_DB ; }
+  { type = GLP_DB ; }
   else
   if (lower > -inf)
-  { type = LPX_LO ; }
+  { type = GLP_LO ; }
   else
   if (upper < inf)
-  { type = LPX_UP ; }
+  { type = GLP_UP ; }
   else
-  { type = LPX_FR ; }
+  { type = GLP_FR ; }
 
-  lpx_set_row_bnds(lp_,i+1,type,lower,upper) ;
+  glp_set_row_bnds(lp_,i+1,type,lower,upper) ;
 /*
   Update cached vectors, if they exist.
 */
@@ -2123,7 +2118,7 @@ OGSI::setContinuous(int index)
 {
         LPX *model = getMutableModelPtr();
 	freeCachedData( OGSI::FREECACHED_COLUMN );
-	lpx_set_col_kind( model, index+1, LPX_CV );
+	glp_set_col_kind( model, index+1, GLP_CV );
 }
 
 //-----------------------------------------------------------------------------
@@ -2132,7 +2127,7 @@ void OGSI::setInteger (int index)
 
 { LPX *model = getMutableModelPtr() ;
   freeCachedData(OGSI::FREECACHED_COLUMN) ;
-  lpx_set_col_kind(model,index+1,LPX_IV) ;
+  glp_set_col_kind(model,index+1,GLP_IV) ;
 /*
   Temporary hack to correct upper bounds on general integer variables.
   CoinMpsIO insists on forcing a bound of 1e30 for general integer variables
@@ -2184,9 +2179,9 @@ void OGSI::setObjSense(double s)
 { freeCachedData(OGSI::FREECACHED_RESULTS) ;
 
   if (s <= -1.0)
-  { lpx_set_obj_dir(lp_,LPX_MAX) ; }
+  { glp_set_obj_dir(lp_,GLP_MAX) ; }
   else
-  { lpx_set_obj_dir(lp_,LPX_MIN) ; }
+  { glp_set_obj_dir(lp_,GLP_MIN) ; }
 
   return ; }
 
@@ -2252,12 +2247,12 @@ void OGSI::addCol (const CoinPackedVecto
 		   const double collb, const double colub, const double obj)
 {
   // Note: GLPK expects only non-zero coefficients will be given in 
-  //   lpx_set_mat_col and will abort if there are any zeros.  So any
-  //   zeros must be removed prior to calling lpx_set_mat_col.
+  //   glp_set_mat_col and will abort if there are any zeros.  So any
+  //   zeros must be removed prior to calling glp_set_mat_col.
         LPX *model = getMutableModelPtr();
 	freeCachedData(OGSI::KEEPCACHED_ROW);
 
-	lpx_add_cols( model, 1 );
+	glp_add_cols( model, 1 );
 	int numcols = getNumCols();
 	setColBounds( numcols-1, collb, colub );
 	setObjCoeff( numcols-1, obj );
@@ -2276,7 +2271,7 @@ void OGSI::addCol (const CoinPackedVecto
 	  if (elements[i] != 0.0)
 	    {
 		if ( indices[i]+1 > numrows ) {
-			lpx_add_rows( model, indices[i]+1 - numrows );
+			glp_add_rows( model, indices[i]+1 - numrows );
 			numrows = indices[i]+1;
 			// ??? could do this more efficiently with a single call based on the max
 		}
@@ -2286,7 +2281,7 @@ void OGSI::addCol (const CoinPackedVecto
 		elements_adj[count] = elements[i];
 	    }
 	}
-	lpx_set_mat_col( model, numcols, count, indices_adj, elements_adj );
+	glp_set_mat_col( model, numcols, count, indices_adj, elements_adj );
 	delete [] indices_adj;
 	delete [] elements_adj;
 
@@ -2326,7 +2321,7 @@ OGSI::deleteCols(const int num, const in
 		columnIndicesPlus1[i+1]=columnIndices[i]+1;
 		deleteColNames(columnIndices[i],1);
 	}
-	lpx_del_cols(model,num,columnIndicesPlus1);
+	glp_del_cols(model,num,columnIndicesPlus1);
 	delete [] columnIndicesPlus1;
 
 # if OGSI_TRACK_FRESH > 0
@@ -2344,13 +2339,13 @@ OGSI::addRow (const CoinPackedVectorBase
 	      const double rowlb, const double rowub)
 {
   // Note: GLPK expects only non-zero coefficients will be given in 
-  //   lpx_set_mat_row and will abort if there are any zeros.  So any
-  //   zeros must be removed prior to calling lpx_set_mat_row.
+  //   glp_set_mat_row and will abort if there are any zeros.  So any
+  //   zeros must be removed prior to calling glp_set_mat_row.
 
         LPX *model = getMutableModelPtr();
 	freeCachedData( OGSI::KEEPCACHED_COLUMN );
 
-	lpx_add_rows( model, 1 );
+	glp_add_rows( model, 1 );
 	int numrows = getNumRows();
 	setRowBounds( numrows-1, rowlb, rowub );
 	int i;
@@ -2369,7 +2364,7 @@ OGSI::addRow (const CoinPackedVectorBase
 	    {
 		if ( indices[i]+1 > numcols ) {
 		  // ??? Could do this more efficiently with a single call
-			lpx_add_cols( model, indices[i]+1 - numcols );
+			glp_add_cols( model, indices[i]+1 - numcols );
 			numcols = indices[i]+1;
 		}
 		count++;
@@ -2377,7 +2372,7 @@ OGSI::addRow (const CoinPackedVectorBase
 		indices_adj[count] = indices[i] + 1;
 	    }
 	}
-	lpx_set_mat_row( model, numrows, count, indices_adj, elements_adj );
+	glp_set_mat_row( model, numrows, count, indices_adj, elements_adj );
 	delete [] indices_adj;
 	delete [] elements_adj;
 
@@ -2461,8 +2456,8 @@ void OGSI::deleteRows (const int num, co
   int notBasic = 0 ;
   for (ndx = 1 ; ndx <= num ; ndx++)
   { i = glpkIndices[ndx] ;
-    int stati = lpx_get_row_stat(lp_,i) ;
-    if (stati != LPX_BS)
+    int stati = glp_get_row_stat(lp_,i) ;
+    if (stati != GLP_BS)
     { notBasic++ ; } }
   if (notBasic)
   {
@@ -2476,7 +2471,7 @@ void OGSI::deleteRows (const int num, co
 /*
   Tell glpk to delete the rows.
 */
-  lpx_del_rows(lp_,num,glpkIndices) ;
+  glp_del_rows(lp_,num,glpkIndices) ;
 
   delete [] glpkIndices ;
 
@@ -2511,41 +2506,32 @@ void OGSI::loadProblem (const CoinPacked
   
   In any event, get rid of cached data in the OsiGlpk object.
 */
-  if (lpx_get_num_cols(lp_) != 0 || lpx_get_num_rows(lp_) != 0)
+  if (glp_get_num_cols(lp_) != 0 || glp_get_num_rows(lp_) != 0)
   { 
-    int presolVal = lpx_get_int_parm(lp_,LPX_K_PRESOL) ;
-    int usedualVal = lpx_get_int_parm(lp_,LPX_K_DUAL) ;
-    int scaleVal = lpx_get_int_parm(lp_,LPX_K_SCALE) ;
-    int logVal = lpx_get_int_parm(lp_,LPX_K_MSGLEV) ;
 #   if OGSI_TRACK_FRESH > 0
     std::cout
       << "    emptying LPX(" << std::hex << lp_ << std::dec << "), "
 #   endif
-    lpx_delete_prob(lp_) ;
-    lp_ = lpx_create_prob() ;
+    glp_delete_prob(lp_) ;
+    lp_ = glp_create_prob() ;
     assert(lp_) ;
 #   if OGSI_TRACK_FRESH > 0
     std::cout
       << "loading LPX(" << std::hex << lp_ << std::dec << ")."
       << std::endl ;
 #   endif
-    lpx_set_class(lp_,LPX_MIP) ;
-    lpx_set_int_parm(lp_,LPX_K_ITLIM,maxIteration_) ; 
+    
+    simplexParams_.it_lim = maxIteration_ ; 
     if (getObjSense() == 1)				// minimization
-    { lpx_set_real_parm(lp_,LPX_K_OBJUL,dualObjectiveLimit_) ;
-      lpx_set_real_parm(lp_,LPX_K_OBJLL,primalObjectiveLimit_) ; }
+    { simplexParams_.obj_ul = dualObjectiveLimit_ ;
+      simplexParams_.obj_ll = primalObjectiveLimit_ ; }
     else						// maximization
-    { lpx_set_real_parm(lp_,LPX_K_OBJLL,dualObjectiveLimit_) ;
-      lpx_set_real_parm(lp_,LPX_K_OBJUL,primalObjectiveLimit_) ; }
-    lpx_set_real_parm(lp_,LPX_K_TOLDJ,dualTolerance_) ;
-    lpx_set_real_parm(lp_,LPX_K_TOLBND,primalTolerance_) ;
-    lpx_set_obj_coef(lp_,0,objOffset_) ;
-    lpx_set_prob_name(lp_,const_cast<char *>(probName_.c_str())) ;
-    lpx_set_int_parm(lp_,LPX_K_PRESOL,presolVal) ;
-    lpx_set_int_parm(lp_,LPX_K_DUAL,usedualVal) ;
-    lpx_set_int_parm(lp_,LPX_K_SCALE,scaleVal) ;
-    lpx_set_int_parm(lp_,LPX_K_MSGLEV,logVal) ;
-    messageHandler()->setLogLevel(logVal) ; }
+    { simplexParams_.obj_ll = dualObjectiveLimit_ ;
+      simplexParams_.obj_ul = primalObjectiveLimit_ ; }
+    simplexParams_.tol_dj = dualTolerance_ ;
+    simplexParams_.tol_bnd = primalTolerance_ ;
+    glp_set_obj_coef(lp_,0,objOffset_) ;
+    glp_set_prob_name(lp_,const_cast<char *>(probName_.c_str())) ; }
 
   freeCachedData(OGSI::KEEPCACHED_NONE) ;
 
@@ -2617,7 +2603,7 @@ void OGSI::loadProblem (const CoinPacked
       addCol(reqdBySunCC,collb[j],colub[j],obj[j]) ; }
     // Make sure there are enough rows 
     if (m > getNumRows())
-    { lpx_add_rows(lp_,m-getNumRows()) ; }
+    { glp_add_rows(lp_,m-getNumRows()) ; }
     for (i = 0 ; i < m ; i++)
     { setRowBounds(i,rowlb[i],rowub[i]) ; } }
   else
@@ -2626,7 +2612,7 @@ void OGSI::loadProblem (const CoinPacked
       addRow(reqdBySunCC,rowlb[i],rowub[i]) ; }
     // Make sure there are enough columns
     if (n > getNumCols())
-    { lpx_add_cols(lp_,n-getNumCols()) ; }
+    { glp_add_cols(lp_,n-getNumCols()) ; }
     for (j = 0 ; j < n ; j++)
     { setColBounds(j,collb[j],colub[j]) ;
       setObjCoeff(j,obj[j]) ; } }
@@ -2731,11 +2717,11 @@ OGSI::loadProblem(const int numcols, con
   LPX *model = getMutableModelPtr();
   double inf = getInfinity();
 
-  // Can't send 0 to lpx_add_xxx
+  // Can't send 0 to glp_add_xxx
   if (numcols > 0)
-    lpx_add_cols( model, numcols );
+    glp_add_cols( model, numcols );
   if (numrows > 0)
-    lpx_add_rows( model, numrows );
+    glp_add_rows( model, numrows );
 
   // How many elements?  Column-major, so indices of start are columns
   int numelem = start[ numcols ];
@@ -2756,7 +2742,7 @@ OGSI::loadProblem(const int numcols, con
   {
 	setColBounds( i, collb ? collb[i]:0.0, 
 		    colub ? colub[i]:inf );
-	lpx_set_mat_col( model, i+1, start[i+1]-start[i], &(index_adj[start[i]]), &(value_adj[start[i]]) );
+	glp_set_mat_col( model, i+1, start[i+1]-start[i], &(index_adj[start[i]]), &(value_adj[start[i]]) );
     setObjCoeff( i, obj ? obj[i]:0.0 );
   }
   int j;
@@ -2823,7 +2809,7 @@ void OGSI::writeMps( const char * filena
 	std::string f( filename );
 	std::string e( extension );
 	std::string fullname = f + "." + e;
-	lpx_write_mps( getMutableModelPtr(), const_cast<char*>( fullname.c_str() ));
+	glp_write_mps( getMutableModelPtr(), GLP_MPS_FILE, NULL, const_cast<char*>( fullname.c_str() ));
 #else
 	// Fall back on native MPS writer.  
 	// These few lines of code haven't been tested. 2004/10/15
@@ -2996,17 +2982,17 @@ void OGSI::applyColCut( const OsiColCut
             // update cached version as well
             collower_[column] = lower;
             if( lower == upper )
-              type = LPX_FX;
+              type = GLP_FX;
             else if( lower > -inf && upper < inf )
-              type = LPX_DB;
+              type = GLP_DB;
             else if( lower > -inf )
-              type = LPX_LO;
+              type = GLP_LO;
             else if( upper < inf)
-              type = LPX_UP;
+              type = GLP_UP;
             else
-              type = LPX_FR;
+              type = GLP_FR;
             
-            lpx_set_col_bnds( getMutableModelPtr(), column+1, type, lower, upper );
+            glp_set_col_bnds( getMutableModelPtr(), column+1, type, lower, upper );
           }
         }
         // lower bounds
@@ -3018,17 +3004,17 @@ void OGSI::applyColCut( const OsiColCut
             // update cached version as well
             colupper_[column] = upper;
             if( lower == upper )
-              type = LPX_FX;
+              type = GLP_FX;
             else if( lower > -inf && upper < inf )
-              type = LPX_DB;
+              type = GLP_DB;
             else if( lower > -inf )
-              type = LPX_LO;
+              type = GLP_LO;
             else if( upper < inf)
-              type = LPX_UP;
+              type = GLP_UP;
             else
-              type = LPX_FR;
+              type = GLP_FR;
             
-            lpx_set_col_bnds( getMutableModelPtr(), column+1, type, lower, upper );
+            glp_set_col_bnds( getMutableModelPtr(), column+1, type, lower, upper );
           }
         }
 #endif
@@ -3095,25 +3081,24 @@ void OGSI::gutsOfCopy (const OsiGlpkSolv
   held up on the parent OSI object, so we don't need to worry about copying
   them.
 */
-  intParam = lpx_get_int_parm(srclpx,LPX_K_PRESOL) ;
-  lpx_set_int_parm(lpx,LPX_K_PRESOL,intParam) ;
-  intParam = lpx_get_int_parm(srclpx,LPX_K_DUAL) ;
-  lpx_set_int_parm(lpx,LPX_K_DUAL,intParam) ;
-  intParam = lpx_get_int_parm(srclpx,LPX_K_SCALE) ;
-  lpx_set_int_parm(lpx,LPX_K_SCALE,intParam) ;
+  intoptParams_.presolve = source.intoptParams_.presolve;
+  simplexParams_.presolve = source.simplexParams_.presolve;
+  simplexParams_.meth = source.simplexParams_.meth;
+  scaleFlags_ = source.scaleFlags_;
 /*
   Printing is a bit more complicated. Pull the parameter and set the log
   level in the message handler and set the print parameter in glpk.
 */
-  intParam = lpx_get_int_parm(srclpx,LPX_K_MSGLEV) ;
-  lpx_set_int_parm(lpx,LPX_K_MSGLEV,intParam) ;
-  messageHandler()->setLogLevel(intParam) ;
-
-# ifdef LPX_K_USECUTS
-  intParam=lpx_get_int_parm(lp_,LPX_K_USECUTS);
-  lpx_set_int_parm(lp_,LPX_K_USECUTS,intParam);
-# endif
+  simplexParams_.msg_lev = source.simplexParams_.msg_lev;
+  intoptParams_.msg_lev = source.intoptParams_.msg_lev;
+  messageHandler()->setLogLevel(simplexParams_.msg_lev) ;
+
+  intoptParams_.mir_cuts = source.intoptParams_.mir_cuts;
+  intoptParams_.gmi_cuts = source.intoptParams_.gmi_cuts;
+  intoptParams_.cov_cuts = source.intoptParams_.cov_cuts;
+  intoptParams_.clq_cuts = source.intoptParams_.clq_cuts;
   
+  glp_scale_prob(lp_, scaleFlags_);
 /*
   Now --- do we have a problem loaded? If not, we're done.
 */
@@ -3164,22 +3149,22 @@ void OGSI::gutsOfCopy (const OsiGlpkSolv
   nonsense, then don't bother. Once we've copied the status into the new lpx
   object, do the warm-up.
 */
-  if (lpx_get_status(srclpx) != LPX_UNDEF)
+  if (glp_get_status(srclpx) != GLP_UNDEF)
   { for (j = 1 ; j <= n ; j++)
-    { int statj = lpx_get_col_stat(srclpx,j) ;
-      lpx_set_col_stat(lpx,j,statj) ; }
+    { int statj = glp_get_col_stat(srclpx,j) ;
+      glp_set_col_stat(lpx,j,statj) ; }
     for (i = 1 ; i <= m ; i++)
-    { int stati = lpx_get_row_stat(srclpx,i) ;
-      lpx_set_row_stat(lpx,i,stati) ; }
+    { int stati = glp_get_row_stat(srclpx,i) ;
+      glp_set_row_stat(lpx,i,stati) ; }
 
 #ifndef NDEBUG
-    int retval = lpx_warm_up(lpx) ;
+    int retval = glp_warm_up(lpx) ;
 #endif
 #   if OGSI_TRACK_SOLVERS > 1
     std::cout
-      << "    lpx_warm_up returns " << retval << "." << std::endl ;
+      << "    glp_warm_up returns " << retval << "." << std::endl ;
 #   endif
-    assert(retval == LPX_E_OK) ; }
+    assert(retval == 0) ; }
 
   return ; }
 
@@ -3232,26 +3217,28 @@ void OGSI::gutsOfConstructor()
   isObjUpperLimitReached_ = false ;
   isFeasible_ = false;
 
-  lp_ = lpx_create_prob();
+  lp_ = glp_create_prob();
   assert( lp_ != NULL );
-  // Make all problems MIPs.  See note at top of file.
-  lpx_set_class( lp_, LPX_MIP );
 
+  glp_init_smcp(&simplexParams_);
+  glp_init_iocp(&intoptParams_);
+  scaleFlags_ = GLP_SF_EQ;
+  glp_scale_prob(lp_, scaleFlags_);
   // Push OSI parameters down into LPX object.
-  lpx_set_int_parm(lp_,LPX_K_ITLIM,maxIteration_) ; 
+  simplexParams_.it_lim = maxIteration_;
 
   if (getObjSense() == 1.0)				// minimization
-  { lpx_set_real_parm(lp_,LPX_K_OBJUL,dualObjectiveLimit_) ;
-    lpx_set_real_parm(lp_,LPX_K_OBJLL,primalObjectiveLimit_) ; }
+  { simplexParams_.obj_ul = dualObjectiveLimit_ ;
+    simplexParams_.obj_ll = primalObjectiveLimit_ ; }
   else						// maximization
-  { lpx_set_real_parm(lp_,LPX_K_OBJLL,dualObjectiveLimit_) ;
-    lpx_set_real_parm(lp_,LPX_K_OBJUL,-primalObjectiveLimit_) ; }
-  lpx_set_real_parm(lp_,LPX_K_TOLDJ,dualTolerance_) ;
-  lpx_set_real_parm(lp_,LPX_K_TOLBND,primalTolerance_) ;
+  { simplexParams_.obj_ll = dualObjectiveLimit_ ;
+    simplexParams_.obj_ul = -primalObjectiveLimit_ ; }
+  simplexParams_.tol_dj = dualTolerance_;
+  simplexParams_.tol_bnd = primalTolerance_;
 
-  lpx_set_obj_coef(lp_,0,objOffset_) ;
+  glp_set_obj_coef(lp_,0,objOffset_) ;
 
-  lpx_set_prob_name(lp_,const_cast<char *>(probName_.c_str())) ;
+  glp_set_prob_name(lp_,const_cast<char *>(probName_.c_str())) ;
 
 /* Stefan: with the new simplex algorithm in Glpk 4.31, some netlib instances (e.g., dfl001)
    take very long or get into a cycle.
@@ -3264,22 +3251,16 @@ void OGSI::gutsOfConstructor()
   Printing is a bit more complicated. Set the log level in the handler and set
   the print parameter in glpk.
 */
-  lpx_set_int_parm(lp_,LPX_K_MSGLEV,1) ;
-  messageHandler()->setLogLevel(1) ;
+  simplexParams_.msg_lev = intoptParams_.msg_lev = GLP_MSG_ERR ;
+  messageHandler()->setLogLevel(GLP_MSG_ERR) ;
   
 /*
-  Enable cuts if they're available. This is a bit of a pain,
-  as the interface has changed since it was first introduced in 4.9.
-  LPX_K_USECUTS appears in 4.9; the parameter value
-  appears to be unused in this version. LPX_C_ALL appears in 4.10.
-*/
-# ifdef LPX_K_USECUTS
-# ifdef LPX_C_ALL
-  lpx_set_int_parm(lp_,LPX_K_USECUTS,LPX_C_ALL) ;
-# else
-  lpx_set_int_parm(lp_,LPX_K_USECUTS,0) ;
-# endif
-# endif
+  Enable cuts if they're available.
+*/
+  intoptParams_.mir_cuts = GLP_ON;
+  intoptParams_.gmi_cuts = GLP_ON;
+  intoptParams_.cov_cuts = GLP_ON;
+  intoptParams_.clq_cuts = GLP_ON;
 }
 
 //-----------------------------------------------------------------------------
@@ -3288,7 +3269,7 @@ void OGSI::gutsOfDestructor()
 {
 	if( lp_ != NULL )
 	{
-		lpx_delete_prob( lp_ );
+		glp_delete_prob( lp_ );
 		lp_=NULL;
 		freeAllMemory();
 	}
@@ -3408,7 +3389,7 @@ void OGSI::freeAllMemory()
 void OGSI::setObjName (std::string name)
 
 { OsiSolverInterface::setObjName(name) ;
-  lpx_set_obj_name(lp_,const_cast<char *>(name.c_str())) ; }
+  glp_set_obj_name(lp_,const_cast<char *>(name.c_str())) ; }
 
 /*!
   Set a row name. Make sure both glpk and OSI see the same name.
@@ -3431,7 +3412,7 @@ void OGSI::setRowName (int ndx, std::str
   Set the name in the OSI base, then in the consys structure.
 */
   OsiSolverInterface::setRowName(ndx,name) ;
-  lpx_set_row_name(lp_,ndx+1,const_cast<char *>(name.c_str())) ;
+  glp_set_row_name(lp_,ndx+1,const_cast<char *>(name.c_str())) ;
 
   return ; }
 
@@ -3456,7 +3437,7 @@ void OGSI::setColName (int ndx, std::str
   Set the name in the OSI base, then in the consys structure.
 */
   OsiSolverInterface::setColName(ndx,name) ;
-  lpx_set_col_name(lp_,ndx+1,const_cast<char *>(name.c_str())) ;
+  glp_set_col_name(lp_,ndx+1,const_cast<char *>(name.c_str())) ;
 
   return ; }
 
--- Osi-0.106.10/Osi/src/OsiGlpk/OsiGlpkSolverInterface.hpp.orig	2013-04-06 14:50:19.000000000 +0200
+++ Osi-0.106.10/Osi/src/OsiGlpk/OsiGlpkSolverInterface.hpp	2014-12-03 20:33:20.066812529 +0100
@@ -768,6 +768,9 @@ private:
   //@{
   /// GPLK model represented by this class instance
   mutable LPX* lp_;
+  glp_iocp intoptParams_;
+  glp_smcp simplexParams_;
+  int scaleFlags_;
   
   /// number of GLPK instances currently in use (counts only those created by OsiGlpk) 
   static unsigned int numInstances_;
